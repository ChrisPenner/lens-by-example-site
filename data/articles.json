[{"what":"Prisms","slug":"overview","url":"/articles/prisms/overview","content":"<h1 id=\"prisms\">Prisms</h1>\n<p>Prisms are traversals which focus on a <strong>single</strong> element. That element may or may not be available; meaning that accessing values with prisms may <strong>succeed</strong> or <strong>fail</strong> when using something like <a href=\"/articles/prisms/preview\">preview</a>. Prisms are distinct from traversals however in that they select only a single element and as a result also have the ability to be <strong>reversed</strong>; meaning you can give a prism a single value and it will embed it in the same structure you'd use the prism to access it from! Read more about reversing prisms in the <a href=\"/articles/prisms/review\">review</a> article.</p>\n<p><code>Control.Lens.Prism</code> contains a few generally useful prisms like <code>_Just</code>, <code>_Left</code> and <code>_Right</code>, but <code>lens</code> also provides the <code>makePrisms</code> template haskell macro for generating prisms for all your own data types! Prisms are very often used for <strong>pattern-matching</strong>, especially matching on different data-type constructors! If you use <code>makePrisms</code> on a data-type it will generate a pattern prism for that constructor which which allows you to access the values inside it <em>if</em> the provided value matches the specific constructor of the data-type. You can reverse these pattern prisms with <code>review</code> to have them act as the constructor they match on! Pretty cool! Learn more about constructing prisms in the article on <a href=\"/articles/prisms/writing-prisms\">writing prisms</a>!</p>","title":"Overview","why":"Optics which encompass access with possible failure","section":"Prisms"},{"what":"Preview","slug":"preview","url":"/articles/prisms/preview","content":"<h1 id=\"preview\">Preview</h1>\n<p><code>preview</code> is how we can access a value focused by a Prism while reflecting the possibility of failure. Note that you can actually use any <code>Traversal</code> with <code>preview</code>, but it will only access the first value in the traversal.</p>\n<p>You'll often see <code>preview</code> used as its infix alias <code>^?</code>; preview takes a prism, traversal, or some composition of optics and returns a <code>Maybe</code> of their focus! If the traversal succeeded (i.e. found at least one element) it'll return <code>Just</code> that element, if the traversal had zero elements the preview fails and simply returns <code>Nothing</code>.</p>\n<p>Many prisms focus the contents of a particular constructor of a datatype, failing if the value doesn't match the constructor. E.g. <code>_Right</code> matches <code>Right</code> but not <code>Left</code> and focuses the value inside. <code>_Just</code> focuses the value in a <code>Just</code> but will fail on a <code>Nothing</code>.</p>\n<p>Here're a few examples using some prisms and traversals:</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb1-1\" title=\"1\"><span class=\"co\">-- Successfully match the &#39;Right&#39; constructor</span></a>\n<a class=\"sourceLine\" id=\"cb1-2\" title=\"2\">λ<span class=\"fu\">&gt;</span> <span class=\"dt\">Right</span> <span class=\"dv\">10</span> <span class=\"fu\">^?</span> _Right</a>\n<a class=\"sourceLine\" id=\"cb1-3\" title=\"3\"><span class=\"dt\">Just</span> <span class=\"dv\">10</span></a>\n<a class=\"sourceLine\" id=\"cb1-4\" title=\"4\"><span class=\"co\">-- Fail by using _Left on a &#39;Right&#39;</span></a>\n<a class=\"sourceLine\" id=\"cb1-5\" title=\"5\">λ<span class=\"fu\">&gt;</span> <span class=\"dt\">Right</span> <span class=\"dv\">10</span> <span class=\"fu\">^?</span> _Left</a>\n<a class=\"sourceLine\" id=\"cb1-6\" title=\"6\"><span class=\"dt\">Nothing</span></a>\n<a class=\"sourceLine\" id=\"cb1-7\" title=\"7\"><span class=\"co\">-- _head is a traversal which matches the </span></a>\n<a class=\"sourceLine\" id=\"cb1-8\" title=\"8\"><span class=\"co\">-- first element of a list-like structure</span></a>\n<a class=\"sourceLine\" id=\"cb1-9\" title=\"9\">λ<span class=\"fu\">&gt;</span> [<span class=\"dv\">1</span>, <span class=\"dv\">2</span>, <span class=\"dv\">3</span>] <span class=\"fu\">^?</span> _head</a>\n<a class=\"sourceLine\" id=\"cb1-10\" title=\"10\"><span class=\"dt\">Just</span> <span class=\"dv\">1</span></a>\n<a class=\"sourceLine\" id=\"cb1-11\" title=\"11\">λ<span class=\"fu\">&gt;</span> [] <span class=\"fu\">^?</span> _head</a>\n<a class=\"sourceLine\" id=\"cb1-12\" title=\"12\"><span class=\"dt\">Nothing</span></a>\n<a class=\"sourceLine\" id=\"cb1-13\" title=\"13\"><span class=\"co\">-- Here we use preview to access the *first* element of a fold</span></a>\n<a class=\"sourceLine\" id=\"cb1-14\" title=\"14\">λ<span class=\"fu\">&gt;</span> [<span class=\"dv\">1</span>, <span class=\"dv\">3</span>, <span class=\"dv\">5</span>] <span class=\"fu\">^?</span> traversed <span class=\"fu\">.</span> filtered <span class=\"fu\">odd</span></a>\n<a class=\"sourceLine\" id=\"cb1-15\" title=\"15\"><span class=\"dt\">Just</span> <span class=\"dv\">1</span></a>\n<a class=\"sourceLine\" id=\"cb1-16\" title=\"16\">λ<span class=\"fu\">&gt;</span> [<span class=\"dv\">1</span>, <span class=\"dv\">3</span>, <span class=\"dv\">5</span>] <span class=\"fu\">^?</span> traversed <span class=\"fu\">.</span> filtered <span class=\"fu\">even</span></a>\n<a class=\"sourceLine\" id=\"cb1-17\" title=\"17\"><span class=\"dt\">Nothing</span></a>\n<a class=\"sourceLine\" id=\"cb1-18\" title=\"18\"><span class=\"co\">-- Here&#39;s a deeply nested traversal where we &#39;dive in&#39; to the </span></a>\n<a class=\"sourceLine\" id=\"cb1-19\" title=\"19\"><span class=\"co\">-- (possibly missing) result of &#39;at&#39; using &#39;_Just&#39;. </span></a>\n<a class=\"sourceLine\" id=\"cb1-20\" title=\"20\"><span class=\"co\">-- The whole preview succeeds if every piece along the path </span></a>\n<a class=\"sourceLine\" id=\"cb1-21\" title=\"21\"><span class=\"co\">-- succeeds, and fails if any &#39;match&#39; doesn&#39;t work.</span></a>\n<a class=\"sourceLine\" id=\"cb1-22\" title=\"22\">λ<span class=\"fu\">&gt;</span> M.singleton <span class=\"st\">&quot;key&quot;</span> (M.singleton <span class=\"st\">&quot;nested&quot;</span> <span class=\"st\">&quot;value&quot;</span>)  </a>\n<a class=\"sourceLine\" id=\"cb1-23\" title=\"23\">        <span class=\"fu\">^?</span> at <span class=\"st\">&quot;key&quot;</span> <span class=\"fu\">.</span> _Just <span class=\"fu\">.</span> at <span class=\"st\">&quot;nested&quot;</span> <span class=\"fu\">.</span> _Just</a>\n<a class=\"sourceLine\" id=\"cb1-24\" title=\"24\"><span class=\"dt\">Just</span> <span class=\"st\">&quot;value&quot;</span></a>\n<a class=\"sourceLine\" id=\"cb1-25\" title=\"25\">λ<span class=\"fu\">&gt;</span> M.singleton <span class=\"st\">&quot;key&quot;</span> (M.singleton <span class=\"st\">&quot;nested&quot;</span> <span class=\"st\">&quot;value&quot;</span>)  </a>\n<a class=\"sourceLine\" id=\"cb1-26\" title=\"26\">        <span class=\"fu\">^?</span> at <span class=\"st\">&quot;missing&quot;</span> <span class=\"fu\">.</span> _Just <span class=\"fu\">.</span> at <span class=\"st\">&quot;something&quot;</span></a>\n<a class=\"sourceLine\" id=\"cb1-27\" title=\"27\"><span class=\"dt\">Nothing</span></a></code></pre></div>\n<p>You can also use prisms as traversals when setting or mutating values, but similar to traversals they will do nothing if the values they focus don't exist.</p>\n<div class=\"sourceCode\" id=\"cb2\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb2-1\" title=\"1\">λ<span class=\"fu\">&gt;</span> <span class=\"dt\">Left</span> <span class=\"dv\">1</span> <span class=\"fu\">&amp;</span> _Left <span class=\"fu\">*~</span> <span class=\"dv\">100</span></a>\n<a class=\"sourceLine\" id=\"cb2-2\" title=\"2\"><span class=\"dt\">Left</span> <span class=\"dv\">100</span></a>\n<a class=\"sourceLine\" id=\"cb2-3\" title=\"3\">λ<span class=\"fu\">&gt;</span> <span class=\"dt\">Left</span> <span class=\"dv\">1</span> <span class=\"fu\">&amp;</span> _Right <span class=\"fu\">*~</span> <span class=\"dv\">100</span></a>\n<a class=\"sourceLine\" id=\"cb2-4\" title=\"4\"><span class=\"dt\">Left</span> <span class=\"dv\">1</span></a>\n<a class=\"sourceLine\" id=\"cb2-5\" title=\"5\">λ<span class=\"fu\">&gt;</span>  M.fromList [(<span class=\"st\">&quot;key&quot;</span>, <span class=\"dv\">1</span>), (<span class=\"st\">&quot;otherkey&quot;</span>, <span class=\"dv\">5</span>)]  <span class=\"fu\">&amp;</span> at <span class=\"st\">&quot;key&quot;</span> <span class=\"fu\">.</span> _Just <span class=\"fu\">*~</span> <span class=\"dv\">100</span></a>\n<a class=\"sourceLine\" id=\"cb2-6\" title=\"6\">fromList [(<span class=\"st\">&quot;key&quot;</span>,<span class=\"dv\">100</span>),(<span class=\"st\">&quot;otherkey&quot;</span>,<span class=\"dv\">5</span>)]</a></code></pre></div>\n<p>Notice that in the last example given above we can mutate the element at the key using <code>_Just</code>, but can't change its type in the mutation because that would cause a single element of the Map to have a different type than the others.</p>\n<h1 id=\"pattern-matching\">Pattern Matching</h1>\n<p>Prisms are useful for representing pattern-matching using combinators rather than <code>case</code>. Unlike syntax constructs for pattern matching they can be passed to functions, stored in data-structures etc. Here are a few examples of using <code>has</code>, <code>hasn't</code> and <code>isn't</code> to check the success of pattern matches over some prisms by returning <code>True</code> or <code>False</code>:</p>\n<div class=\"sourceCode\" id=\"cb3\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb3-1\" title=\"1\">λ<span class=\"fu\">&gt;</span> has _Right (<span class=\"dt\">Right</span> <span class=\"st\">&quot;Hi&quot;</span>)</a>\n<a class=\"sourceLine\" id=\"cb3-2\" title=\"2\"><span class=\"dt\">True</span></a>\n<a class=\"sourceLine\" id=\"cb3-3\" title=\"3\">λ<span class=\"fu\">&gt;</span> has _Right (<span class=\"dt\">Left</span> <span class=\"st\">&quot;Hi&quot;</span>)</a>\n<a class=\"sourceLine\" id=\"cb3-4\" title=\"4\"><span class=\"dt\">False</span></a>\n<a class=\"sourceLine\" id=\"cb3-5\" title=\"5\">λ<span class=\"fu\">&gt;</span> isn&#39;t _Empty [<span class=\"dv\">1</span>,<span class=\"dv\">2</span>,<span class=\"dv\">3</span>]</a>\n<a class=\"sourceLine\" id=\"cb3-6\" title=\"6\"><span class=\"dt\">True</span></a>\n<a class=\"sourceLine\" id=\"cb3-7\" title=\"7\">λ<span class=\"fu\">&gt;</span> isn&#39;t _Empty []</a>\n<a class=\"sourceLine\" id=\"cb3-8\" title=\"8\"><span class=\"dt\">False</span></a></code></pre></div>\n<p><code>is</code> is strangely missing from <code>lens</code>, but <code>has</code> does the trick just fine; in fact <code>has</code> and <code>hasn't</code> seem to be more general than <code>isn't</code> in that they work over all <code>fold</code>s and don't require a <code>Prism</code>.</p>","title":"Preview","why":"Access a Prism's focus with possible failure","section":"Prisms"},{"what":"Review","slug":"review","url":"/articles/prisms/review","content":"<h1 id=\"review\">Review</h1>\n<p>Prisms differentiate themselves from simple traversals by allowing you to <strong>reverse</strong> them and embed a value in a structure. There are a few common uses for this technique:</p>\n<ul>\n<li>Prisms as ad-hoc constructors/pattern matching</li>\n<li>Composable nested constructors for embedding a value deep inside a structure</li>\n<li>Lifting values (often errors/exceptions) between types</li>\n</ul>\n<p>Let's take a peek at how review works with some common <em>constructor</em> prisms.</p>\n<h1 id=\"prisms-as-constructors\">Prisms as Constructors</h1>\n<p>As a convention, prisms which correspond to constructors are named as <code>_ConstructorName</code>; some examples from <code>Control.Lens.Prism</code> include <code>_Left</code>, <code>_Right</code>, <code>_Just</code> and <code>_Nothing</code>. Each of these constructors happen to contain only a single element, which is convenient since review can only embed a single value, but we'll show a workaround using tuples in a bit. When used as traversals with <code>preview</code> (a.k.a. <code>^?</code>) these prisms <em>unpack</em> the constructor. E.g. <code>_Just</code> selects the <code>a</code> from <code>Just a</code> and fails on <code>Nothing</code>. <code>review</code> (a.k.a. <code>#</code>) on the other hand takes an <code>a</code> and embeds it in the constructor such that <code>review _Just a = Just a</code>. Unlike <code>preview</code> which may fail to find the value we want, <code>review</code> will always succeed in embedding the value we give it.</p>\n<p>Be wary, most but not <strong>all</strong> Prisms are <code>review</code>able. Those written by <code>makePrisms</code> are fair game, but when you start writing more advanced prisms using the <code>prism</code> helper with differing <code>s</code> and <code>t</code> types you may run into trouble. That's content for another article altogether.</p>\n<p>When looking at a <code>Prism s t a b</code> type signature the important parts for <code>review</code> are <code>t</code> and <code>b</code>, the 'simplified' type of <code>review</code> is <code>review :: Prism' t b -&gt; b -&gt; t</code></p>\n<p>Here are a few examples constructing values using <code>#</code>; the infix version of <code>review</code>:</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb1-1\" title=\"1\">λ<span class=\"fu\">&gt;</span>_Just <span class=\"fu\">#</span> <span class=\"st\">&quot;hello&quot;</span></a>\n<a class=\"sourceLine\" id=\"cb1-2\" title=\"2\"><span class=\"dt\">Just</span> <span class=\"st\">&quot;hello&quot;</span></a>\n<a class=\"sourceLine\" id=\"cb1-3\" title=\"3\">λ<span class=\"fu\">&gt;</span> _Left <span class=\"fu\">#</span> <span class=\"dv\">42</span></a>\n<a class=\"sourceLine\" id=\"cb1-4\" title=\"4\"><span class=\"dt\">Left</span> <span class=\"dv\">42</span></a>\n<a class=\"sourceLine\" id=\"cb1-5\" title=\"5\">λ<span class=\"fu\">&gt;</span> _Right <span class=\"fu\">#</span> <span class=\"dt\">Just</span> <span class=\"dv\">1337</span></a>\n<a class=\"sourceLine\" id=\"cb1-6\" title=\"6\"><span class=\"dt\">Right</span> (<span class=\"dt\">Just</span> <span class=\"dv\">1337</span>)</a></code></pre></div>\n<p>Hopefully that's pretty clear!</p>\n<p>Before we move on let's address a common problem, what do we do in the case where one of our constructors has more than a single value inside? Not to fret, we can easily pack up our multiple values into a tuple and use that instead!</p>\n<h1 id=\"complex-constructors\">Complex Constructors</h1>\n<p>Here's an example using <code>_Cons</code> from <code>Control.Lens.Cons</code>, it allows unpacking a sequence into the first value of that sequence and the rest of the sequence, failing if there are no values to split off. This shows us that if we need more than one value to build up some structure we can just build a prism which operates over a tuple of those values.</p>\n<div class=\"sourceCode\" id=\"cb2\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb2-1\" title=\"1\">λ<span class=\"fu\">&gt;</span> [<span class=\"dv\">1</span>, <span class=\"dv\">2</span>, <span class=\"dv\">3</span>] <span class=\"fu\">^?</span> _Cons</a>\n<a class=\"sourceLine\" id=\"cb2-2\" title=\"2\"><span class=\"dt\">Just</span> (<span class=\"dv\">1</span>, [<span class=\"dv\">2</span>, <span class=\"dv\">3</span>])</a>\n<a class=\"sourceLine\" id=\"cb2-3\" title=\"3\">λ<span class=\"fu\">&gt;</span> (<span class=\"dv\">1</span>, [<span class=\"dv\">2</span>, <span class=\"dv\">3</span>]) <span class=\"fu\">#</span> _Cons</a>\n<a class=\"sourceLine\" id=\"cb2-4\" title=\"4\">[<span class=\"dv\">1</span>, <span class=\"dv\">2</span>, <span class=\"dv\">3</span>]</a></code></pre></div>\n<p>This also allows us to represent pattern matching using prisms on more complex union types! Consider the following type:</p>\n<div class=\"sourceCode\" id=\"cb3\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb3-1\" title=\"1\"><span class=\"kw\">data</span> <span class=\"dt\">RegexMatch</span> <span class=\"fu\">=</span></a>\n<a class=\"sourceLine\" id=\"cb3-2\" title=\"2\">      <span class=\"dt\">NoMatch</span>              <span class=\"co\">-- regex failed to match</span></a>\n<a class=\"sourceLine\" id=\"cb3-3\" title=\"3\">    <span class=\"fu\">|</span> <span class=\"dt\">Match</span> <span class=\"dt\">String</span> <span class=\"dt\">String</span>  <span class=\"co\">-- Matched string and remaining string</span></a>\n<a class=\"sourceLine\" id=\"cb3-4\" title=\"4\">    <span class=\"fu\">|</span> <span class=\"dt\">Matches</span> [<span class=\"dt\">String</span>]     <span class=\"co\">-- list of matches</span></a>\n<a class=\"sourceLine\" id=\"cb3-5\" title=\"5\"></a>\n<a class=\"sourceLine\" id=\"cb3-6\" title=\"6\">makePrisms &#39;<span class=\"dt\">&#39;RegexMatch</span></a></code></pre></div>\n<p>Here we have a few constructors for the results of running a regex match, (not comprehensive I know, don't <code>@</code> me). We have a few interesting cases to examine, <code>NoMatch</code> contains <strong>no</strong> fields, <code>Match</code> contains <strong>two</strong> fields, and <code>Matches</code> contains a <strong>single</strong> field!</p>\n<p>In general you can use <code>makePrisms</code> provided by <code>lens</code> to write prisms for your datatypes; but if you want to write your own you can read about that <a href=\"/articles/prisms/writing-prisms\">here</a>. Let's see what it did for each of these cases!</p>\n<p>If you load them up in ghci and check their type with <code>:type</code> you'll see jargon like:</p>\n<div class=\"sourceCode\" id=\"cb4\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb4-1\" title=\"1\">_Match</a>\n<a class=\"sourceLine\" id=\"cb4-2\" title=\"2\"><span class=\"ot\">  ::</span> (<span class=\"dt\">Choice</span> p, <span class=\"dt\">Applicative</span> f) <span class=\"ot\">=&gt;</span></a>\n<a class=\"sourceLine\" id=\"cb4-3\" title=\"3\">     p (<span class=\"dt\">String</span>, <span class=\"dt\">String</span>) (f (<span class=\"dt\">String</span>, <span class=\"dt\">String</span>))</a>\n<a class=\"sourceLine\" id=\"cb4-4\" title=\"4\">     <span class=\"ot\">-&gt;</span> p <span class=\"dt\">RegexMatch</span> (f <span class=\"dt\">RegexMatch</span>)</a></code></pre></div>\n<p>These signatures take a bit of practice to read, once you learn to squint properly and get a bit of practice you can recognize it as:</p>\n<div class=\"sourceCode\" id=\"cb5\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb5-1\" title=\"1\"><span class=\"ot\">_Match ::</span> <span class=\"dt\">Prism&#39;</span> <span class=\"dt\">RegexMatch</span> (<span class=\"dt\">String</span>, <span class=\"dt\">String</span>)</a></code></pre></div>\n<p>If you're unsure of your guess, feel free to punch it back into ghci and see if it agrees; (ghci <em>loves</em> to contradict you).</p>\n<div class=\"sourceCode\" id=\"cb6\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb6-1\" title=\"1\">λ<span class=\"fu\">&gt;</span> <span class=\"kw\">let</span> x <span class=\"fu\">=</span><span class=\"ot\"> _Match ::</span> <span class=\"dt\">Prism&#39;</span> <span class=\"dt\">RegexMatch</span> (<span class=\"dt\">String</span>, <span class=\"dt\">String</span>)</a></code></pre></div>\n<p>If you get it right ghci will hum along happily, otherwise it'll spit profanity at you to let you know you've guessed incorrectly.</p>\n<p>After a bit of guessing you'll see it generated prisms of the following types for you:</p>\n<div class=\"sourceCode\" id=\"cb7\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb7-1\" title=\"1\"><span class=\"ot\">_NoMatch ::</span> <span class=\"dt\">Prism&#39;</span> <span class=\"dt\">RegexMatch</span> ()</a>\n<a class=\"sourceLine\" id=\"cb7-2\" title=\"2\"><span class=\"ot\">_Match ::</span> <span class=\"dt\">Prism&#39;</span> <span class=\"dt\">RegexMatch</span> (<span class=\"dt\">String</span>, <span class=\"dt\">String</span>)</a>\n<a class=\"sourceLine\" id=\"cb7-3\" title=\"3\"><span class=\"ot\">_Matches ::</span> <span class=\"dt\">Prism&#39;</span> <span class=\"dt\">RegexMatch</span> [<span class=\"dt\">String</span>]</a></code></pre></div>\n<p>Nothing too special about <code>_Matches</code>, it focuses a single thing which is a list of Strings, we see that <code>_Match</code> is a bit more interesting: it packs up the two values of <code>Match</code> into a tuple for us! Lastly is <code>_NoMatch</code>, which is a bit strange. It focuses <code>()</code>, meaning it doesn't really extract any real information for us. What could we use this for? Well for one we can still construct <code>NoMatch</code> using <code>review</code> with this prism, which may be helpful just for consistency reasons (although I'd recommend the actual constructor in most cases), it's also useful when used with checking functions such as <code>has</code>, <code>hasn't</code> or <code>isn't</code>, we talk about this in the article on <a href=\"/articles/prisms/preview\">preview</a></p>\n<h1 id=\"composing-constructors\">Composing Constructors</h1>\n<p>Prisms compose! And they act as you might expect! We can compose our various prisms with <code>review</code> and we'll construct a nested object. Take a peek:</p>\n<div class=\"sourceCode\" id=\"cb8\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb8-1\" title=\"1\">λ<span class=\"fu\">&gt;</span> _Left <span class=\"fu\">.</span> _Just <span class=\"fu\">#</span> <span class=\"dv\">42</span></a>\n<a class=\"sourceLine\" id=\"cb8-2\" title=\"2\"><span class=\"dt\">Left</span> (<span class=\"dt\">Just</span> <span class=\"dv\">42</span>)</a></code></pre></div>\n<p>This isn't really all that different than composing the constructors themselves in this case, but it's helpful for consistency, works for more creative prisms, and when writing things using Classy Prisms as well!</p>\n<p>This is particularly helpful when working with error types in real applications. Oftentimes when composing monad stacks you may need to surface errors from multiple independent parts of your application. In a simple application for example it may be possible to get a database error or a network error. We can represent each distinct class of errors as different types, each has a few constructors representing different errors which might occur.</p>\n<div class=\"sourceCode\" id=\"cb9\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb9-1\" title=\"1\"><span class=\"kw\">data</span> <span class=\"dt\">DatabaseError</span> <span class=\"fu\">=</span> <span class=\"dt\">NoConnections</span></a>\n<a class=\"sourceLine\" id=\"cb9-2\" title=\"2\">                   <span class=\"fu\">|</span> <span class=\"dt\">DBError</span> <span class=\"dt\">String</span></a>\n<a class=\"sourceLine\" id=\"cb9-3\" title=\"3\">                   <span class=\"fu\">|</span> <span class=\"dt\">TransactionFailed</span> <span class=\"dt\">String</span></a>\n<a class=\"sourceLine\" id=\"cb9-4\" title=\"4\">                   <span class=\"kw\">deriving</span> <span class=\"dt\">Show</span></a>\n<a class=\"sourceLine\" id=\"cb9-5\" title=\"5\">makePrisms &#39;<span class=\"dt\">&#39;DatabaseError</span></a>\n<a class=\"sourceLine\" id=\"cb9-6\" title=\"6\"></a>\n<a class=\"sourceLine\" id=\"cb9-7\" title=\"7\"><span class=\"kw\">data</span> <span class=\"dt\">NetworkError</span> <span class=\"fu\">=</span> <span class=\"dt\">Error500</span> <span class=\"dt\">String</span></a>\n<a class=\"sourceLine\" id=\"cb9-8\" title=\"8\">                  <span class=\"fu\">|</span> <span class=\"dt\">TLSError</span> <span class=\"dt\">String</span></a>\n<a class=\"sourceLine\" id=\"cb9-9\" title=\"9\">                  <span class=\"kw\">deriving</span> <span class=\"dt\">Show</span></a>\n<a class=\"sourceLine\" id=\"cb9-10\" title=\"10\">makePrisms &#39;<span class=\"dt\">&#39;NetworkError</span></a></code></pre></div>\n<p>If we're using these errors in a real application we'll likely have to unify them into a single error type so they can be raised in something like an <code>ExceptT</code> monad. We can make a new type to hold either of these error types:</p>\n<div class=\"sourceCode\" id=\"cb10\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb10-1\" title=\"1\"><span class=\"kw\">data</span> <span class=\"dt\">AppError</span> <span class=\"fu\">=</span> <span class=\"dt\">ErrorDB</span> <span class=\"dt\">DatabaseError</span></a>\n<a class=\"sourceLine\" id=\"cb10-2\" title=\"2\">              <span class=\"fu\">|</span> <span class=\"dt\">ErrorNetwork</span> <span class=\"dt\">NetworkError</span></a>\n<a class=\"sourceLine\" id=\"cb10-3\" title=\"3\">              <span class=\"kw\">deriving</span> <span class=\"dt\">Show</span></a>\n<a class=\"sourceLine\" id=\"cb10-4\" title=\"4\">makePrisms &#39;<span class=\"dt\">&#39;AppError</span></a></code></pre></div>\n<p>Now that we've got prisms for each error type and for each constructor of the combined <code>AppError</code> we can easily create an <code>AppError</code> of the correct type:</p>\n<div class=\"sourceCode\" id=\"cb11\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb11-1\" title=\"1\">λ<span class=\"fu\">&gt;</span> _ErrorDB <span class=\"fu\">.</span> _TransactionFailed <span class=\"fu\">#</span> <span class=\"st\">&quot;Contention on User Record&quot;</span></a>\n<a class=\"sourceLine\" id=\"cb11-2\" title=\"2\"><span class=\"dt\">ErrorDB</span> (<span class=\"dt\">TransactionFailed</span> <span class=\"st\">&quot;Contention on User Record&quot;</span>)</a></code></pre></div>\n<p>This becomes even more useful if we replace our concrete prisms with 'Classy' prisms which allow us to write the composition of prisms once and use a single prism to nest errors as far as needed. That's a topic for another article, but in the meantime you can watch a <a href=\"https://www.youtube.com/watch?v=GZPup5Iuaqw\">fantastic talk by George Wilson</a> about how it works.</p>\n<h1 id=\"reviewing-isos\">Reviewing Isos</h1>\n<p>A nifty trick is that Isos can also be reviewed! Since an Iso is <em>Iso</em>morphic to a pair of functions <code>(a -&gt; b, b -&gt; a)</code> review on an <code>Iso a b</code> corresponds to running the Iso backwards, i.e. applying the <code>b -&gt; a</code> function to the input. Since you can also view through an Iso forwards we get the equalities:</p>\n<div class=\"sourceCode\" id=\"cb12\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb12-1\" title=\"1\">val <span class=\"fu\">^.</span> iso      <span class=\"fu\">=</span> from iso <span class=\"fu\">#</span> val</a>\n<a class=\"sourceLine\" id=\"cb12-2\" title=\"2\">val <span class=\"fu\">^.</span> from iso <span class=\"fu\">=</span> iso <span class=\"fu\">#</span> val</a></code></pre></div>\n<p>Let's write a simple iso to map from chars to integers (this iso is undefined on certain integers, but it's good enough for teaching purposes):</p>\n<div class=\"sourceCode\" id=\"cb13\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb13-1\" title=\"1\"><span class=\"ot\">char&#39;ing ::</span> <span class=\"dt\">Iso&#39;</span> <span class=\"dt\">Int</span> <span class=\"dt\">Char</span></a>\n<a class=\"sourceLine\" id=\"cb13-2\" title=\"2\">char&#39;ing <span class=\"fu\">=</span> iso <span class=\"fu\">chr</span> <span class=\"fu\">ord</span></a></code></pre></div>\n<p>Using this Iso we can see integers as characters by <code>view</code>ing through it, and can reverse the relationship with <code>review</code>!</p>\n<div class=\"sourceCode\" id=\"cb14\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb14-1\" title=\"1\">λ<span class=\"fu\">&gt;</span> <span class=\"dv\">65</span> <span class=\"fu\">^.</span> char&#39;ing</a>\n<a class=\"sourceLine\" id=\"cb14-2\" title=\"2\"><span class=\"ch\">&#39;A&#39;</span></a>\n<a class=\"sourceLine\" id=\"cb14-3\" title=\"3\">λ<span class=\"fu\">&gt;</span> char&#39;ing <span class=\"fu\">#</span> <span class=\"ch\">&#39;A&#39;</span></a>\n<a class=\"sourceLine\" id=\"cb14-4\" title=\"4\"><span class=\"dv\">65</span></a></code></pre></div>\n<p>If we want to construct the other value with review we can use <code>from</code> to reverse the iso.</p>\n<div class=\"sourceCode\" id=\"cb15\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb15-1\" title=\"1\">λ<span class=\"fu\">&gt;</span> from char&#39;ing <span class=\"fu\">#</span> <span class=\"dv\">65</span></a>\n<a class=\"sourceLine\" id=\"cb15-2\" title=\"2\"><span class=\"ch\">&#39;A&#39;</span></a></code></pre></div>\n<p>Isos and prisms are all composable! Here's a useless example where we set a string field inside a constructor by composing the <code>reversed</code> and <code>packed</code> isos with the prism for our constructor!</p>\n<div class=\"sourceCode\" id=\"cb16\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb16-1\" title=\"1\">λ<span class=\"fu\">&gt;</span> _TransactionFailed <span class=\"fu\">.</span> packed <span class=\"fu\">.</span> reversed <span class=\"fu\">#</span> (<span class=\"st\">&quot;hello&quot;</span><span class=\"ot\"> ::</span> <span class=\"dt\">T.Text</span>)</a>\n<a class=\"sourceLine\" id=\"cb16-2\" title=\"2\"><span class=\"dt\">TransactionFailed</span> <span class=\"st\">&quot;olleh&quot;</span></a></code></pre></div>\n<p>If you have a lot of data mangling to do it can be pretty handy to keep isos and prisms for your conversions around! Use a prism if the conversion could fail in one of the directions, and an iso if the round-trip is guaranteed to work!</p>\n<p>Here's an example of <code>_Show :: (Read a, Show a) =&gt; Prism' String a</code> which <code>reviews</code> values through <code>show</code> and can <code>read</code> values from strings with a possibility of failure.</p>\n<div class=\"sourceCode\" id=\"cb17\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb17-1\" title=\"1\"><span class=\"co\">-- preview:</span></a>\n<a class=\"sourceLine\" id=\"cb17-2\" title=\"2\">λ<span class=\"fu\">&gt;</span> <span class=\"st\">&quot;72&quot;</span> <span class=\"fu\">^?</span><span class=\"ot\"> _Show ::</span> <span class=\"dt\">Maybe</span> <span class=\"dt\">Int</span></a>\n<a class=\"sourceLine\" id=\"cb17-3\" title=\"3\"><span class=\"dt\">Just</span> <span class=\"dv\">72</span></a>\n<a class=\"sourceLine\" id=\"cb17-4\" title=\"4\">λ<span class=\"fu\">&gt;</span> <span class=\"st\">&quot;hrmm?&quot;</span> <span class=\"fu\">^?</span><span class=\"ot\"> _Show ::</span> <span class=\"dt\">Maybe</span> <span class=\"dt\">Int</span></a>\n<a class=\"sourceLine\" id=\"cb17-5\" title=\"5\"><span class=\"dt\">Nothing</span></a>\n<a class=\"sourceLine\" id=\"cb17-6\" title=\"6\"><span class=\"co\">-- review:</span></a>\n<a class=\"sourceLine\" id=\"cb17-7\" title=\"7\">λ<span class=\"fu\">&gt;</span> _Show <span class=\"fu\">#</span> <span class=\"dv\">72</span></a>\n<a class=\"sourceLine\" id=\"cb17-8\" title=\"8\"><span class=\"st\">&quot;72&quot;</span></a>\n<a class=\"sourceLine\" id=\"cb17-9\" title=\"9\">λ<span class=\"fu\">&gt;</span> _Show <span class=\"fu\">#</span> [<span class=\"dv\">1</span>, <span class=\"dv\">2</span>, <span class=\"dv\">3</span>]</a>\n<a class=\"sourceLine\" id=\"cb17-10\" title=\"10\"><span class=\"st\">&quot;[1,2,3]&quot;</span></a></code></pre></div>","title":"Review","why":"Prisms may be turned around such that they embed values in a larger structure rather than extracting them","section":"Prisms"},{"what":"Writing Prisms","slug":"writing-prisms","url":"/articles/prisms/writing-prisms","content":"<h1 id=\"writing-prisms\">Writing Prisms</h1>\n<p>Although you can write prisms for any potentially failing access oftentimes prisms correspond to data constructors. For this purpose we can use <code>TemplateHaskell</code> to generate prisms for our data types.</p>\n<h1 id=\"template-haskell\">Template Haskell</h1>\n<p>Here's a simple data-type representing a few possible results from running a regex match.</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb1-1\" title=\"1\"><span class=\"kw\">data</span> <span class=\"dt\">RegexMatch</span> <span class=\"fu\">=</span></a>\n<a class=\"sourceLine\" id=\"cb1-2\" title=\"2\">      <span class=\"dt\">NoMatch</span>              <span class=\"co\">-- regex failed to match</span></a>\n<a class=\"sourceLine\" id=\"cb1-3\" title=\"3\">    <span class=\"fu\">|</span> <span class=\"dt\">Match</span> <span class=\"dt\">String</span> <span class=\"dt\">String</span>  <span class=\"co\">-- Matched string and remaining string</span></a>\n<a class=\"sourceLine\" id=\"cb1-4\" title=\"4\">    <span class=\"fu\">|</span> <span class=\"dt\">Matches</span> [<span class=\"dt\">String</span>]     <span class=\"co\">-- list of matches</span></a>\n<a class=\"sourceLine\" id=\"cb1-5\" title=\"5\"></a>\n<a class=\"sourceLine\" id=\"cb1-6\" title=\"6\">makePrisms &#39;<span class=\"dt\">&#39;RegexMatch</span></a></code></pre></div>\n<p>The last line using <code>makeLenses</code> will generate a prism for each of our constructors (you'll need the <code>TemplateHaskell</code> language pragma though). When constructors have more than one value the generated prisms pack the values up into tuples and use those, if there are no contained values the prism simply uses <code>()</code> as a stand-in. The actual type signatures are a bit messier (as is tradition for the lens library), but the simplified signatures for our <code>RegexMatch</code> prisms look like this:</p>\n<div class=\"sourceCode\" id=\"cb2\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb2-1\" title=\"1\"><span class=\"ot\">_NoMatch ::</span> <span class=\"dt\">Prism&#39;</span> <span class=\"dt\">RegexMatch</span> ()</a>\n<a class=\"sourceLine\" id=\"cb2-2\" title=\"2\"><span class=\"ot\">_Match ::</span> <span class=\"dt\">Prism&#39;</span> <span class=\"dt\">RegexMatch</span> (<span class=\"dt\">String</span>, <span class=\"dt\">String</span>)</a>\n<a class=\"sourceLine\" id=\"cb2-3\" title=\"3\"><span class=\"ot\">_Matches ::</span> <span class=\"dt\">Prism&#39;</span> <span class=\"dt\">RegexMatch</span> [<span class=\"dt\">String</span>]</a></code></pre></div>\n<p>Notice that each of these are simple prisms (<code>Prism'</code> rather than <code>Prism</code>). This is because the prism can't change the <strong>type</strong> of its focus in this case; it's hard-coded to be a string. Each of these prisms is reversable with review; read about how to do that <a href=\"/articles/prisms/review\">here</a>.</p>\n<h1 id=\"constructing-prisms\">Constructing Prisms</h1>\n<p>In the case where you want a more complex prism than Template Haskell can generate for you, the <code>lens</code> library provides <code>prism</code> and <code>prism'</code> helper functions for writing your own!</p>\n<p>Similar to the <code>Prism</code> and <code>Prism'</code> type synonyms, <code>prism'</code> can construct simple prisms which do not allow the larger structure to change types although the focus of the prism may change types provided you have some way to map it back to the same <code>s</code> type. With that single exception you'll probably use <code>prism'</code> to generate a <code>Prism'</code> and <code>prism</code> to make a <code>Prism</code>!</p>\n<p>For an example we'll write a strange type which represents some value which may or may not have been validated yet:</p>\n<div class=\"sourceCode\" id=\"cb3\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb3-1\" title=\"1\"><span class=\"kw\">data</span> <span class=\"dt\">Validated</span> a <span class=\"fu\">=</span></a>\n<a class=\"sourceLine\" id=\"cb3-2\" title=\"2\">  <span class=\"dt\">Validated</span></a>\n<a class=\"sourceLine\" id=\"cb3-3\" title=\"3\">    <span class=\"dt\">Bool</span>  <span class=\"co\">-- True if the contents have been validated, false otherwise</span></a>\n<a class=\"sourceLine\" id=\"cb3-4\" title=\"4\">    a     <span class=\"co\">-- the possibly valid contents</span></a>\n<a class=\"sourceLine\" id=\"cb3-5\" title=\"5\">  <span class=\"kw\">deriving</span> <span class=\"dt\">Show</span></a></code></pre></div>\n<p>Now let's write a prism which focuses the contained value if and only if the it has been validated already! To do so we pass <code>prism'</code> two functions: one which embeds a value at the focus of a larger context, and the other which gets the focus out of the larger structure or fail.</p>\n<div class=\"sourceCode\" id=\"cb4\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb4-1\" title=\"1\"><span class=\"ot\">_Valid ::</span> <span class=\"dt\">Prism&#39;</span> (<span class=\"dt\">Validated</span> a) a</a>\n<a class=\"sourceLine\" id=\"cb4-2\" title=\"2\">_Valid <span class=\"fu\">=</span> prism&#39; constructor getter</a>\n<a class=\"sourceLine\" id=\"cb4-3\" title=\"3\"> <span class=\"kw\">where</span></a>\n<a class=\"sourceLine\" id=\"cb4-4\" title=\"4\">  <span class=\"co\">-- This will be used when our prism is &#39;reviewed&#39;</span></a>\n<a class=\"sourceLine\" id=\"cb4-5\" title=\"5\"><span class=\"ot\">  constructor ::</span> a <span class=\"ot\">-&gt;</span> <span class=\"dt\">Validated</span> a</a>\n<a class=\"sourceLine\" id=\"cb4-6\" title=\"6\">  constructor a <span class=\"fu\">=</span> <span class=\"dt\">Validated</span> <span class=\"dt\">True</span> a</a>\n<a class=\"sourceLine\" id=\"cb4-7\" title=\"7\">  <span class=\"co\">-- Get the value if it has been validated, return Nothing otherwise</span></a>\n<a class=\"sourceLine\" id=\"cb4-8\" title=\"8\"><span class=\"ot\">  getter ::</span> <span class=\"dt\">Validated</span> a <span class=\"ot\">-&gt;</span> <span class=\"dt\">Maybe</span> a</a>\n<a class=\"sourceLine\" id=\"cb4-9\" title=\"9\">  getter (<span class=\"dt\">Validated</span> <span class=\"dt\">True</span>  a) <span class=\"fu\">=</span> <span class=\"dt\">Just</span> a</a>\n<a class=\"sourceLine\" id=\"cb4-10\" title=\"10\">  getter (<span class=\"dt\">Validated</span> <span class=\"dt\">False</span> _) <span class=\"fu\">=</span> <span class=\"dt\">Nothing</span></a></code></pre></div>\n<p>Here we're using <code>prism'</code> so we know we get a <code>Prism'</code>, in this case one between the larger structure and the focused value.</p>\n<p>Let's try it out!</p>\n<div class=\"sourceCode\" id=\"cb5\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb5-1\" title=\"1\"><span class=\"co\">-- Constructing with &#39;review&#39;</span></a>\n<a class=\"sourceLine\" id=\"cb5-2\" title=\"2\">λ<span class=\"fu\">&gt;</span> _Valid <span class=\"fu\">#</span> <span class=\"st\">&quot;test@example.com&quot;</span></a>\n<a class=\"sourceLine\" id=\"cb5-3\" title=\"3\"><span class=\"dt\">Validated</span> <span class=\"dt\">True</span> <span class=\"st\">&quot;test@example.com&quot;</span></a>\n<a class=\"sourceLine\" id=\"cb5-4\" title=\"4\"></a>\n<a class=\"sourceLine\" id=\"cb5-5\" title=\"5\"><span class=\"co\">-- Accessing a validated value</span></a>\n<a class=\"sourceLine\" id=\"cb5-6\" title=\"6\">λ<span class=\"fu\">&gt;</span> <span class=\"dt\">Validated</span> <span class=\"dt\">True</span> <span class=\"st\">&quot;me@chrispenner.ca&quot;</span> <span class=\"fu\">^?</span> _Valid</a>\n<a class=\"sourceLine\" id=\"cb5-7\" title=\"7\"><span class=\"dt\">Just</span> <span class=\"st\">&quot;me@chrispenner.ca&quot;</span></a>\n<a class=\"sourceLine\" id=\"cb5-8\" title=\"8\"></a>\n<a class=\"sourceLine\" id=\"cb5-9\" title=\"9\"><span class=\"co\">-- Failing to access an unvalidated value</span></a>\n<a class=\"sourceLine\" id=\"cb5-10\" title=\"10\">λ<span class=\"fu\">&gt;</span> <span class=\"dt\">Validated</span> <span class=\"dt\">False</span>  <span class=\"st\">&quot;spam@shadytown&quot;</span> <span class=\"fu\">^?</span> _Valid</a>\n<a class=\"sourceLine\" id=\"cb5-11\" title=\"11\"><span class=\"dt\">Nothing</span></a></code></pre></div>\n<p>We should also quickly test that we pass the prism laws, there are two!</p>\n<p>The first states that if we <code>preview</code> something that we've <code>review</code>ed we should get the same thing back (in a <code>Just</code>)</p>\n<div class=\"sourceCode\" id=\"cb6\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb6-1\" title=\"1\">preview _Valid (review _Valid b) ≡ <span class=\"dt\">Just</span> b</a>\n<a class=\"sourceLine\" id=\"cb6-2\" title=\"2\"></a>\n<a class=\"sourceLine\" id=\"cb6-3\" title=\"3\"><span class=\"co\">-- Let&#39;s try it!</span></a>\n<a class=\"sourceLine\" id=\"cb6-4\" title=\"4\">λ<span class=\"fu\">&gt;</span> preview _Valid (review _Valid <span class=\"dv\">42</span>)</a>\n<a class=\"sourceLine\" id=\"cb6-5\" title=\"5\"><span class=\"dt\">Just</span> <span class=\"dv\">42</span></a></code></pre></div>\n<p>Secondly if we preview a lens on a value and get a <code>Just</code>, then reviewing that <code>a</code> should get us a value exactly equal to the original.</p>\n<p>More succinctly: If <code>preview l s ≡ Just a</code> then <code>review l a ≡ s</code></p>\n<p>Let's try that:</p>\n<div class=\"sourceCode\" id=\"cb7\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb7-1\" title=\"1\">λ<span class=\"fu\">&gt;</span> preview _Valid (<span class=\"dt\">Validated</span> <span class=\"dt\">True</span> <span class=\"st\">&quot;brucewayne@example.com&quot;</span>)</a>\n<a class=\"sourceLine\" id=\"cb7-2\" title=\"2\"><span class=\"dt\">Just</span> <span class=\"st\">&quot;brucewayne@example.com&quot;</span></a>\n<a class=\"sourceLine\" id=\"cb7-3\" title=\"3\">λ<span class=\"fu\">&gt;</span> review _Valid <span class=\"st\">&quot;brucewayne@example.com&quot;</span></a>\n<a class=\"sourceLine\" id=\"cb7-4\" title=\"4\"><span class=\"dt\">Validated</span> <span class=\"dt\">True</span> <span class=\"st\">&quot;brucewayne@example.com&quot;</span></a></code></pre></div>\n<p>Great! Looks like we're passing both prism laws, at least for the simple cases we've tried. This ensures that if we use our prism with combinators in the <code>lens</code> library that things will behave as expected.</p>\n<p>It seems at first glance that we should be able to allow our <code>_Valid</code> lens to change the type of the value contained inside right? Perhaps to allow us to do something like the following:</p>\n<div class=\"sourceCode\" id=\"cb8\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb8-1\" title=\"1\">λ<span class=\"fu\">&gt;</span> <span class=\"dt\">Validated</span> <span class=\"dt\">True</span> <span class=\"dv\">42</span> <span class=\"fu\">&amp;</span> _Valid <span class=\"fu\">%~</span> <span class=\"fu\">show</span></a>\n<a class=\"sourceLine\" id=\"cb8-2\" title=\"2\"><span class=\"co\">-- We want the following, but actually fail with a type error:</span></a>\n<a class=\"sourceLine\" id=\"cb8-3\" title=\"3\"><span class=\"dt\">Validated</span> <span class=\"dt\">True</span> <span class=\"st\">&quot;42&quot;</span></a></code></pre></div>\n<p>So let's see if this is something we can do if we upgrade to <code>prism</code>!</p>\n<p>The difference from <code>prism'</code> to <code>prism</code> is in the 'getter' function, the <code>prism'</code> version returns <code>Just</code> the value or <code>Nothing</code>, the type-changing version used in <code>prism</code> must be able to construct some base value of the new base type even in the failing case; and so instead of <code>getter :: s -&gt; Maybe a</code> we now have <code>getter: s -&gt; Either t a</code>. That is, we return <code>Right focus</code> if the focus exists, or a <code>Left</code> of some structure of the new type otherwise. If we try using this for our type we run into a problem!</p>\n<div class=\"sourceCode\" id=\"cb9\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb9-1\" title=\"1\"><span class=\"ot\">_Valid&#39; ::</span> <span class=\"kw\">forall</span> a b<span class=\"fu\">.</span> <span class=\"dt\">Prism</span> (<span class=\"dt\">Validated</span> a) (<span class=\"dt\">Validated</span> b) a b</a>\n<a class=\"sourceLine\" id=\"cb9-2\" title=\"2\">_Valid&#39; <span class=\"fu\">=</span> prism constructor getter</a>\n<a class=\"sourceLine\" id=\"cb9-3\" title=\"3\"> <span class=\"kw\">where</span></a>\n<a class=\"sourceLine\" id=\"cb9-4\" title=\"4\"><span class=\"ot\">  constructor ::</span> a <span class=\"ot\">-&gt;</span> <span class=\"dt\">Validated</span> a</a>\n<a class=\"sourceLine\" id=\"cb9-5\" title=\"5\">  constructor a <span class=\"fu\">=</span> <span class=\"dt\">Validated</span> <span class=\"dt\">True</span> a</a>\n<a class=\"sourceLine\" id=\"cb9-6\" title=\"6\"><span class=\"ot\">  getter ::</span> <span class=\"dt\">Validated</span> a <span class=\"ot\">-&gt;</span> <span class=\"dt\">Either</span> (<span class=\"dt\">Validated</span> b) a</a>\n<a class=\"sourceLine\" id=\"cb9-7\" title=\"7\">  getter (<span class=\"dt\">Validated</span> isValid a) <span class=\"fu\">=</span> </a>\n<a class=\"sourceLine\" id=\"cb9-8\" title=\"8\">  <span class=\"kw\">if</span> isValid </a>\n<a class=\"sourceLine\" id=\"cb9-9\" title=\"9\">    <span class=\"kw\">then</span> <span class=\"dt\">Right</span> a</a>\n<a class=\"sourceLine\" id=\"cb9-10\" title=\"10\">    <span class=\"co\">-- WHOOPS! We need something of type b, but don&#39;t have anything!</span></a>\n<a class=\"sourceLine\" id=\"cb9-11\" title=\"11\">    <span class=\"kw\">else</span> <span class=\"dt\">Left</span> (<span class=\"dt\">Validated</span> isValid <span class=\"fu\">???</span>) </a></code></pre></div>\n<p>In our case we'll always have something of type <code>a</code>, but only want to edit it when it's valid. This works with the simple prism, but if we want to allow type changing we need to fix this issue by making the types of our valid and invalid values distinct.</p>\n<div class=\"sourceCode\" id=\"cb10\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb10-1\" title=\"1\"><span class=\"kw\">data</span> <span class=\"dt\">Validated&#39;</span> invalid valid <span class=\"fu\">=</span></a>\n<a class=\"sourceLine\" id=\"cb10-2\" title=\"2\">      <span class=\"dt\">Valid</span> valid</a>\n<a class=\"sourceLine\" id=\"cb10-3\" title=\"3\">    <span class=\"fu\">|</span> <span class=\"dt\">Invalid</span> invalid</a>\n<a class=\"sourceLine\" id=\"cb10-4\" title=\"4\">    <span class=\"kw\">deriving</span> <span class=\"dt\">Show</span></a></code></pre></div>\n<p>Now we have separate constructors and we can vary the types of valid and invalid data separately. Now let's write our prism again!</p>\n<div class=\"sourceCode\" id=\"cb11\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb11-1\" title=\"1\">_Valid&#39;</a>\n<a class=\"sourceLine\" id=\"cb11-2\" title=\"2\"><span class=\"ot\">  ::</span> <span class=\"dt\">Prism</span></a>\n<a class=\"sourceLine\" id=\"cb11-3\" title=\"3\">       (<span class=\"dt\">Validated&#39;</span> invalid valid)</a>\n<a class=\"sourceLine\" id=\"cb11-4\" title=\"4\">       (<span class=\"dt\">Validated&#39;</span> invalid newValid)</a>\n<a class=\"sourceLine\" id=\"cb11-5\" title=\"5\">       valid</a>\n<a class=\"sourceLine\" id=\"cb11-6\" title=\"6\">       newValid</a>\n<a class=\"sourceLine\" id=\"cb11-7\" title=\"7\">_Valid&#39; <span class=\"fu\">=</span> prism constructor getter</a>\n<a class=\"sourceLine\" id=\"cb11-8\" title=\"8\"> <span class=\"kw\">where</span></a>\n<a class=\"sourceLine\" id=\"cb11-9\" title=\"9\">  <span class=\"co\">-- This will be used when our prism is &#39;reviewed&#39;</span></a>\n<a class=\"sourceLine\" id=\"cb11-10\" title=\"10\"><span class=\"ot\">  constructor ::</span> valid <span class=\"ot\">-&gt;</span> <span class=\"dt\">Validated&#39;</span> invalid valid</a>\n<a class=\"sourceLine\" id=\"cb11-11\" title=\"11\">  constructor a <span class=\"fu\">=</span> <span class=\"dt\">Valid</span> a</a>\n<a class=\"sourceLine\" id=\"cb11-12\" title=\"12\">  <span class=\"co\">-- Get the value if it has been validated</span></a>\n<a class=\"sourceLine\" id=\"cb11-13\" title=\"13\">  <span class=\"co\">-- Otherwise we need to return something something</span></a>\n<a class=\"sourceLine\" id=\"cb11-14\" title=\"14\">  <span class=\"co\">-- of the expected result type: `Validated&#39; invalid newValid`</span></a>\n<a class=\"sourceLine\" id=\"cb11-15\" title=\"15\">  getter</a>\n<a class=\"sourceLine\" id=\"cb11-16\" title=\"16\"><span class=\"ot\">    ::</span> <span class=\"dt\">Validated&#39;</span> invalid valid</a>\n<a class=\"sourceLine\" id=\"cb11-17\" title=\"17\">    <span class=\"ot\">-&gt;</span> <span class=\"dt\">Either</span> (<span class=\"dt\">Validated&#39;</span> invalid newValid) valid</a>\n<a class=\"sourceLine\" id=\"cb11-18\" title=\"18\">  getter (<span class=\"dt\">Valid</span>   valid  ) <span class=\"fu\">=</span> <span class=\"dt\">Right</span> valid</a>\n<a class=\"sourceLine\" id=\"cb11-19\" title=\"19\">  getter (<span class=\"dt\">Invalid</span> invalid) <span class=\"fu\">=</span> <span class=\"dt\">Left</span> (<span class=\"dt\">Invalid</span> invalid)</a></code></pre></div>\n<p>That'll do it! Now we can change the type contained in our <code>Validated'</code> type using a prism:</p>\n<div class=\"sourceCode\" id=\"cb12\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb12-1\" title=\"1\">λ<span class=\"fu\">&gt;</span> <span class=\"dt\">Valid</span> <span class=\"dv\">42</span> <span class=\"fu\">&amp;</span> _Valid&#39; <span class=\"fu\">%~</span> <span class=\"fu\">show</span></a>\n<a class=\"sourceLine\" id=\"cb12-2\" title=\"2\"><span class=\"dt\">Valid</span> <span class=\"st\">&quot;42&quot;</span></a></code></pre></div>\n<p>Keen observers will realize that we actually just rewrote <code>Either</code> but with a new name! What can I say? 🙈</p>\n<p>That wraps writing simple Prisms!</p>","title":"Writing Prisms","why":"Prisms represent the concept of a traversal which may fail, preview represents access with failure","section":"Prisms"},{"what":"Learn to write and compose traversals","slug":"writing-traversals","url":"/articles/traversals/writing-traversals","content":"<h1 id=\"writing-traversals\">Writing Traversals</h1>\n<p>Traversals are one of the most adaptable and useful optics. In short they let you:</p>\n<ul>\n<li>Access and change deeply nested parts of state</li>\n<li>Access multiple parts of a structure at once</li>\n<li>'Focus' on each of multiple elements 'pretending' you're only working with one element at a time</li>\n</ul>\n<p>How do Traversals fit into the lens hierarchy?</p>\n<ul>\n<li>All <code>Lens</code>es are usable as <code>Traversal</code>s over a single element</li>\n<li>All traversals are also <code>Folds</code></li>\n<li>Most traversals are <code>Indexable</code> and can contain location info. E.g. index in their list, key of a <code>Map</code></li>\n</ul>\n<p>Most lens tutorials show you how to use and compose traversals, but most skim over how to WRITE complex traversals. Let's dive in!</p>\n<h2 id=\"simple-traversals\">Simple Traversals</h2>\n<p>We'll start of with our imports and extensions:</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb1-1\" title=\"1\"><span class=\"kw\">module</span> <span class=\"dt\">Examples.Traversals.Writing</span> <span class=\"kw\">where</span></a>\n<a class=\"sourceLine\" id=\"cb1-2\" title=\"2\"></a>\n<a class=\"sourceLine\" id=\"cb1-3\" title=\"3\"><span class=\"kw\">import</span>           <span class=\"dt\">Control.Lens</span></a>\n<a class=\"sourceLine\" id=\"cb1-4\" title=\"4\"><span class=\"kw\">import</span> <span class=\"kw\">qualified</span> <span class=\"dt\">Data.Map</span>                      <span class=\"kw\">as</span> <span class=\"dt\">M</span></a></code></pre></div>\n<p>Let's start with the simplest possible traversal! In fact this is the type you'll probably use the most often. Let's say we work at a bank and we have a type which represents a simple bank transaction:</p>\n<div class=\"sourceCode\" id=\"cb2\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb2-1\" title=\"1\"><span class=\"kw\">data</span> <span class=\"dt\">Transaction</span> <span class=\"fu\">=</span></a>\n<a class=\"sourceLine\" id=\"cb2-2\" title=\"2\">    <span class=\"dt\">Withdrawal</span> {<span class=\"ot\">amount ::</span> <span class=\"dt\">Int</span>}</a>\n<a class=\"sourceLine\" id=\"cb2-3\" title=\"3\">    <span class=\"fu\">|</span> <span class=\"dt\">Deposit</span> {<span class=\"ot\">amount ::</span> <span class=\"dt\">Int</span> }</a>\n<a class=\"sourceLine\" id=\"cb2-4\" title=\"4\">  <span class=\"kw\">deriving</span> <span class=\"dt\">Show</span></a></code></pre></div>\n<p>We have two constructors, one for withdrawals, one for deposits. Each have the <code>amount</code> accessor which gets the amount of the transaction within <strong>either</strong> of the constructors.</p>\n<p>Great! Let's write our first simple traversal! Let's say we have a list of Transactions and we want to focus on each element of that list using a traversal. Any time we're writing a traversal over a data type which implements <code>Traversable</code> over the focus we want then we can actually use the traversable instance to write our traversal for us! Here's what it looks like:</p>\n<div class=\"sourceCode\" id=\"cb3\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb3-1\" title=\"1\"><span class=\"ot\">simpleTransactions ::</span> <span class=\"dt\">Traversal&#39;</span> [<span class=\"dt\">Transaction</span>] <span class=\"dt\">Transaction</span></a>\n<a class=\"sourceLine\" id=\"cb3-2\" title=\"2\">simpleTransactions <span class=\"fu\">=</span> <span class=\"fu\">traverse</span></a></code></pre></div>\n<p>What?? Yup it's that simple! turns out that the signature of a traversal is <strong>identical</strong> to that of the actual <code>traverse</code> function! Any time something is traversable we can just use <code>traverse</code>; and in fact there's no reason to define this traversal ourselves unless we want an alias for clarity. In this case we've actually defined a <strong>worse</strong> traversal than just using <code>traverse</code> directly, can you see why? Let's learn how to read the type signatures of Traversals!</p>\n<div class=\"sourceCode\" id=\"cb4\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb4-1\" title=\"1\"><span class=\"dt\">Traversal&#39;</span> s a</a>\n<a class=\"sourceLine\" id=\"cb4-2\" title=\"2\"><span class=\"co\">-- a.k.a.</span></a>\n<a class=\"sourceLine\" id=\"cb4-3\" title=\"3\"><span class=\"dt\">Traversal&#39;</span> structure focus</a>\n<a class=\"sourceLine\" id=\"cb4-4\" title=\"4\"><span class=\"co\">-- a.k.a.</span></a>\n<a class=\"sourceLine\" id=\"cb4-5\" title=\"5\"><span class=\"dt\">Traversal&#39;</span> [<span class=\"dt\">Transaction</span>] <span class=\"dt\">Transaction</span></a></code></pre></div>\n<p>The lens library has a convention where a suffix of <code>'</code> means to use a 'simple' form of the provided type. For traversals this means that anything with a type of <code>Traversal' s a</code> is <strong>NOT</strong> allowed to change the type of the structure or focused value. In our example this means that when using the <code>simpleTransactions</code> traversal we <strong>can't change Transaction into some other type</strong>. If we try we'll see an error:</p>\n<div class=\"sourceCode\" id=\"cb5\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb5-1\" title=\"1\"><span class=\"ot\">someTransactions ::</span> [<span class=\"dt\">Transaction</span>]</a>\n<a class=\"sourceLine\" id=\"cb5-2\" title=\"2\">someTransactions <span class=\"fu\">=</span> [<span class=\"dt\">Deposit</span> <span class=\"dv\">100</span>, <span class=\"dt\">Withdrawal</span> <span class=\"dv\">50</span>]</a>\n<a class=\"sourceLine\" id=\"cb5-3\" title=\"3\"></a>\n<a class=\"sourceLine\" id=\"cb5-4\" title=\"4\">λ<span class=\"fu\">&gt;</span> someTransactions <span class=\"fu\">&amp;</span> simpleTransactions <span class=\"fu\">.~</span> <span class=\"st\">&quot;a string&quot;</span></a>\n<a class=\"sourceLine\" id=\"cb5-5\" title=\"5\"></a>\n<a class=\"sourceLine\" id=\"cb5-6\" title=\"6\"><span class=\"fu\">error:</span></a>\n<a class=\"sourceLine\" id=\"cb5-7\" title=\"7\">    • <span class=\"dt\">Couldn&#39;t</span> match expected <span class=\"kw\">type</span> ‘<span class=\"dt\">Transaction</span>’</a>\n<a class=\"sourceLine\" id=\"cb5-8\" title=\"8\">                  with actual <span class=\"kw\">type</span> ‘[<span class=\"dt\">Char</span>]’</a>\n<a class=\"sourceLine\" id=\"cb5-9\" title=\"9\">    • <span class=\"dt\">In</span> the second argument <span class=\"kw\">of</span> ‘(<span class=\"fu\">.~</span>)’, namely ‘<span class=\"st\">&quot;a string&quot;</span>’</a>\n<a class=\"sourceLine\" id=\"cb5-10\" title=\"10\">      <span class=\"dt\">In</span> the second argument <span class=\"kw\">of</span> ‘(<span class=\"fu\">&amp;</span>)’, namely</a>\n<a class=\"sourceLine\" id=\"cb5-11\" title=\"11\">        ‘simpleTransactions <span class=\"fu\">.~</span> <span class=\"st\">&quot;a string&quot;</span>’</a>\n<a class=\"sourceLine\" id=\"cb5-12\" title=\"12\">      <span class=\"dt\">In</span> the expression<span class=\"fu\">:</span></a>\n<a class=\"sourceLine\" id=\"cb5-13\" title=\"13\">        someTransactions <span class=\"fu\">&amp;</span> simpleTransactions <span class=\"fu\">.~</span> <span class=\"st\">&quot;a string&quot;</span></a></code></pre></div>\n<p>Let's fix this by relaxing our type signature to allow the traversal to change the type of the focus.</p>\n<div class=\"sourceCode\" id=\"cb6\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb6-1\" title=\"1\">typeChangingTransactions</a>\n<a class=\"sourceLine\" id=\"cb6-2\" title=\"2\"><span class=\"ot\">  ::</span> <span class=\"dt\">Traversal</span> [<span class=\"dt\">Transaction</span>] [result] <span class=\"dt\">Transaction</span> result</a>\n<a class=\"sourceLine\" id=\"cb6-3\" title=\"3\">typeChangingTransactions <span class=\"fu\">=</span> <span class=\"fu\">traverse</span></a></code></pre></div>\n<p>Now we're using the non-simplified type <code>Traversal s t a b</code>; as usual the <code>stab</code> types mean:</p>\n<ul>\n<li><code>s</code>: Starting structure, e.g. <code>[Transaction]</code> in our case</li>\n<li><code>t</code>: Ending structure, e.g. <code>[result]</code></li>\n<li><code>a</code>: Starting focus, e.g. <code>Transaction</code></li>\n<li><code>b</code>: Ending focus, e.g. <code>result</code></li>\n</ul>\n<p>Now that we've relaxed the type signature we can use it to change the type of our transactions if we like:</p>\n<div class=\"sourceCode\" id=\"cb7\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb7-1\" title=\"1\">λ<span class=\"fu\">&gt;</span> someTransactions <span class=\"fu\">&amp;</span> typeChangingTransactions <span class=\"fu\">.~</span> <span class=\"st\">&quot;a string&quot;</span></a>\n<a class=\"sourceLine\" id=\"cb7-2\" title=\"2\">[<span class=\"st\">&quot;a string&quot;</span>,<span class=\"st\">&quot;a string&quot;</span>]</a></code></pre></div>\n<p>In practice you probably shouldn't bother writing these types of traversals yourself, just use provided <code>traversed</code> traversal which depends on the <code>Traversal</code> instance and also passes indexing information if you end up wanting it.</p>\n<h2 id=\"selective-traversals\">Selective Traversals</h2>\n<p>The default traversal works great if you want to select every element of a traversable structure, but what if we only want to select withdrawal transactions? Time to write our own custom traversal!</p>\n<p>Remember how <code>traverse</code> is a valid traversal? That means we can write our own traversal by matching the type signature of <code>traverse</code> itself!</p>\n<div class=\"sourceCode\" id=\"cb8\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb8-1\" title=\"1\"><span class=\"fu\">traverse</span> </a>\n<a class=\"sourceLine\" id=\"cb8-2\" title=\"2\"><span class=\"ot\">  ::</span> (<span class=\"dt\">Traversable</span> t, <span class=\"dt\">Applicative</span> f) </a>\n<a class=\"sourceLine\" id=\"cb8-3\" title=\"3\">  <span class=\"ot\">=&gt;</span> (a <span class=\"ot\">-&gt;</span> f b) <span class=\"ot\">-&gt;</span> t a <span class=\"ot\">-&gt;</span> f (t b)</a></code></pre></div>\n<p>Let's constrain the type so it matches what we want to do, in our case we want to focus on the amount of withdrawal transactions, so given a list of transactions we can access the <code>Int</code>s inside JUST the withdrawals.</p>\n<p>Using the shorthand notation that gives us:</p>\n<div class=\"sourceCode\" id=\"cb9\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb9-1\" title=\"1\"><span class=\"ot\">withdrawals ::</span> <span class=\"dt\">Traversal&#39;</span> [<span class=\"dt\">Transaction</span>] <span class=\"dt\">Int</span></a>\n<a class=\"sourceLine\" id=\"cb9-2\" title=\"2\"><span class=\"co\">-- a.k.a.</span></a>\n<a class=\"sourceLine\" id=\"cb9-3\" title=\"3\"><span class=\"ot\">withdrawals ::</span> <span class=\"dt\">Traversal</span> [<span class=\"dt\">Transaction</span>] [<span class=\"dt\">Transaction</span>] <span class=\"dt\">Int</span> <span class=\"dt\">Int</span></a></code></pre></div>\n<p>Notice that this sort of operation does <strong>not</strong> allow us to change any of the types, so we use the <code>Traversal'</code> notation, but that doesn't help us write our actual function, so let's take a look at the signature of <code>traverse</code> specialized to <code>withdrawals</code>:</p>\n<div class=\"sourceCode\" id=\"cb10\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb10-1\" title=\"1\"><span class=\"ot\">withdrawals ::</span> (<span class=\"dt\">Applicative</span> f) </a>\n<a class=\"sourceLine\" id=\"cb10-2\" title=\"2\">            <span class=\"ot\">=&gt;</span> (<span class=\"dt\">Int</span> <span class=\"ot\">-&gt;</span> f <span class=\"dt\">Int</span>) </a>\n<a class=\"sourceLine\" id=\"cb10-3\" title=\"3\">            <span class=\"ot\">-&gt;</span> [ <span class=\"dt\">Transaction</span> ] </a>\n<a class=\"sourceLine\" id=\"cb10-4\" title=\"4\">            <span class=\"ot\">-&gt;</span> f [ <span class=\"dt\">Transaction</span> ]</a></code></pre></div>\n<p>This means that our <code>withdrawals</code> traversal must take a function as an argument, that function <em>wraps</em> an <code>Int</code> into <strong>some</strong> Applicative structure, but we're <strong>NOT</strong> allowed to pick which Applicative! <code>withdrawals</code> needs to use that function to somehow wrap the whole list of <code>Transaction</code>s in the unknown applicative. This should look pretty familiar if you've ever implemented <code>Traversable</code> by hand, the difference is that here we're allowed to know a bit of extra info about the types we're traversing!</p>\n<p>Let's see if we can write something which at least type-checks with this signature:</p>\n<div class=\"sourceCode\" id=\"cb11\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb11-1\" title=\"1\">allAmounts</a>\n<a class=\"sourceLine\" id=\"cb11-2\" title=\"2\"><span class=\"ot\">  ::</span> (<span class=\"dt\">Applicative</span> f)</a>\n<a class=\"sourceLine\" id=\"cb11-3\" title=\"3\">  <span class=\"ot\">=&gt;</span> (<span class=\"dt\">Int</span> <span class=\"ot\">-&gt;</span> f <span class=\"dt\">Int</span>)</a>\n<a class=\"sourceLine\" id=\"cb11-4\" title=\"4\">  <span class=\"ot\">-&gt;</span> [<span class=\"dt\">Transaction</span>]</a>\n<a class=\"sourceLine\" id=\"cb11-5\" title=\"5\">  <span class=\"ot\">-&gt;</span> f [<span class=\"dt\">Transaction</span>]</a>\n<a class=\"sourceLine\" id=\"cb11-6\" title=\"6\">allAmounts f ts <span class=\"fu\">=</span> <span class=\"fu\">traverse</span> go ts</a>\n<a class=\"sourceLine\" id=\"cb11-7\" title=\"7\"> <span class=\"kw\">where</span></a>\n<a class=\"sourceLine\" id=\"cb11-8\" title=\"8\">  go (<span class=\"dt\">Withdrawal</span> amt) <span class=\"fu\">=</span> <span class=\"dt\">Withdrawal</span> <span class=\"fu\">&lt;$&gt;</span> f amt</a>\n<a class=\"sourceLine\" id=\"cb11-9\" title=\"9\">  go (<span class=\"dt\">Deposit</span>    amt) <span class=\"fu\">=</span> <span class=\"dt\">Deposit</span> <span class=\"fu\">&lt;$&gt;</span> f amt</a></code></pre></div>\n<p>Here we're relying on the generic <code>traverse</code> function for our list type, but we have to manually unpack and re-wrap each <code>Transaction</code> using <code>go</code> because it's not generically traversable over the contained amount. Inside <code>go</code> we have to rely on <code>&lt;$&gt;</code> (a.k.a. <code>fmap</code>) since we don't actually know which Applicative will be chosen when the traversal is eventually used.</p>\n<p>This type-checks, <em>BUT</em> it makes no discrimination between <code>Withdrawal</code>s and <code>Deposit</code>s! In fact the traversal we've written selects the <code>Int</code> amount of both withdrawals AND deposits. A quick way to debug your traversals is to simply fold the selected elements into a list using <code>(^..)</code>. Let's see how <code>allTransactions</code> behaves:</p>\n<div class=\"sourceCode\" id=\"cb12\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb12-1\" title=\"1\"><span class=\"ot\">someTransactions ::</span> [<span class=\"dt\">Transaction</span>]</a>\n<a class=\"sourceLine\" id=\"cb12-2\" title=\"2\">someTransactions <span class=\"fu\">=</span> [<span class=\"dt\">Deposit</span> <span class=\"dv\">100</span>, <span class=\"dt\">Withdrawal</span> <span class=\"dv\">50</span>]</a>\n<a class=\"sourceLine\" id=\"cb12-3\" title=\"3\"></a>\n<a class=\"sourceLine\" id=\"cb12-4\" title=\"4\">λ<span class=\"fu\">&gt;</span> someTransactions <span class=\"fu\">^..</span> allAmounts</a>\n<a class=\"sourceLine\" id=\"cb12-5\" title=\"5\">[<span class=\"dv\">100</span>,<span class=\"dv\">50</span>]</a></code></pre></div>\n<p>So it's pretty clear we're focusing both deposits and withdrawals.</p>\n<p>We need to somehow tell the traversal which <code>Int</code>s we care about and which we don't! We do this by selecting the values we care about using the provided <code>f</code> and ignore the values we don't by lifting them with <code>pure</code>. You can think of it as though <code>f</code> <strong>marks</strong> focused values while <code>pure</code> <strong>ignores</strong> them. Let's alter our traversal accordingly!</p>\n<div class=\"sourceCode\" id=\"cb13\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb13-1\" title=\"1\"><span class=\"co\">-- withdrawals :: Traversal&#39; [Transaction] Int</span></a>\n<a class=\"sourceLine\" id=\"cb13-2\" title=\"2\"><span class=\"co\">-- a.k.a.</span></a>\n<a class=\"sourceLine\" id=\"cb13-3\" title=\"3\">withdrawals</a>\n<a class=\"sourceLine\" id=\"cb13-4\" title=\"4\"><span class=\"ot\">  ::</span> (<span class=\"dt\">Applicative</span> f)</a>\n<a class=\"sourceLine\" id=\"cb13-5\" title=\"5\">  <span class=\"ot\">=&gt;</span> (<span class=\"dt\">Int</span> <span class=\"ot\">-&gt;</span> f <span class=\"dt\">Int</span>)</a>\n<a class=\"sourceLine\" id=\"cb13-6\" title=\"6\">  <span class=\"ot\">-&gt;</span> [<span class=\"dt\">Transaction</span>]</a>\n<a class=\"sourceLine\" id=\"cb13-7\" title=\"7\">  <span class=\"ot\">-&gt;</span> f [<span class=\"dt\">Transaction</span>]</a>\n<a class=\"sourceLine\" id=\"cb13-8\" title=\"8\">withdrawals f ts <span class=\"fu\">=</span> <span class=\"fu\">traverse</span> go ts</a>\n<a class=\"sourceLine\" id=\"cb13-9\" title=\"9\"> <span class=\"kw\">where</span></a>\n<a class=\"sourceLine\" id=\"cb13-10\" title=\"10\">  go (<span class=\"dt\">Withdrawal</span> amt) <span class=\"fu\">=</span> <span class=\"dt\">Withdrawal</span> <span class=\"fu\">&lt;$&gt;</span> f amt</a>\n<a class=\"sourceLine\" id=\"cb13-11\" title=\"11\">  go (<span class=\"dt\">Deposit</span>    amt) <span class=\"fu\">=</span> <span class=\"dt\">Deposit</span> <span class=\"fu\">&lt;$&gt;</span> <span class=\"fu\">pure</span> amt</a></code></pre></div>\n<p>And let's test out our new traversal, we'll check the focus with <code>^..</code> then try adding <code>$10</code> to all of our withdrawals using <code>+~</code> which adds an amount to numbers selected by a lens or traversal.</p>\n<div class=\"sourceCode\" id=\"cb14\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb14-1\" title=\"1\">λ<span class=\"fu\">&gt;</span> someTransactions <span class=\"fu\">^..</span> withdrawals</a>\n<a class=\"sourceLine\" id=\"cb14-2\" title=\"2\">[<span class=\"dv\">50</span>]</a>\n<a class=\"sourceLine\" id=\"cb14-3\" title=\"3\"></a>\n<a class=\"sourceLine\" id=\"cb14-4\" title=\"4\">λ<span class=\"fu\">&gt;</span> someTransactions <span class=\"fu\">&amp;</span> withdrawals <span class=\"fu\">+~</span> <span class=\"dv\">10</span></a>\n<a class=\"sourceLine\" id=\"cb14-5\" title=\"5\">[<span class=\"dt\">Deposit</span> {amount <span class=\"fu\">=</span> <span class=\"dv\">100</span>},<span class=\"dt\">Withdrawal</span> {amount <span class=\"fu\">=</span> <span class=\"dv\">60</span>}]</a></code></pre></div>\n<p>Looks great!</p>\n<p>One last example as a word of warning, it's tempting to write our <code>withdrawal</code> traversal by <code>filter</code>ing our list down to the values we care about and traversing over those, but don't fall into this trap! If we filter out values from the list they'll be forgotten when we modify values using the traversal!</p>\n<p>Here's an example of what <strong>NOT</strong> to do:</p>\n<div class=\"sourceCode\" id=\"cb15\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb15-1\" title=\"1\"><span class=\"ot\">badWithdrawals ::</span> <span class=\"dt\">Traversal&#39;</span> [<span class=\"dt\">Transaction</span>] <span class=\"dt\">Int</span></a>\n<a class=\"sourceLine\" id=\"cb15-2\" title=\"2\">badWithdrawals f ts <span class=\"fu\">=</span> <span class=\"fu\">traverse</span> go (<span class=\"fu\">filter</span> isWithdrawal ts)</a>\n<a class=\"sourceLine\" id=\"cb15-3\" title=\"3\"> <span class=\"kw\">where</span></a>\n<a class=\"sourceLine\" id=\"cb15-4\" title=\"4\">  isWithdrawal <span class=\"dt\">Withdrawal</span>{} <span class=\"fu\">=</span> <span class=\"dt\">True</span></a>\n<a class=\"sourceLine\" id=\"cb15-5\" title=\"5\">  isWithdrawal _            <span class=\"fu\">=</span> <span class=\"dt\">False</span></a>\n<a class=\"sourceLine\" id=\"cb15-6\" title=\"6\">  go t <span class=\"fu\">=</span> <span class=\"dt\">Withdrawal</span> <span class=\"fu\">&lt;$&gt;</span> f (amount t)</a></code></pre></div>\n<p>Notice how we lose the deposit entirely when we try to edit our withdrawals!</p>\n<div class=\"sourceCode\" id=\"cb16\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb16-1\" title=\"1\">λ<span class=\"fu\">&gt;</span> someTransactions <span class=\"fu\">&amp;</span> badWithdrawals <span class=\"fu\">+~</span> <span class=\"dv\">10</span></a>\n<a class=\"sourceLine\" id=\"cb16-2\" title=\"2\">[<span class=\"dt\">Withdrawal</span> {amount <span class=\"fu\">=</span> <span class=\"dv\">60</span>}]</a></code></pre></div>\n<h2 id=\"traversals-over-embedded-structures\">Traversals over embedded structures</h2>\n<p>So far we know how to write traversals for types which are already traversable, but what if the focus we want is embedded deeper within a newtype or record? Let's expand our example to handle transactions embedded within a bank account data-type!</p>\n<div class=\"sourceCode\" id=\"cb17\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb17-1\" title=\"1\"><span class=\"kw\">data</span> <span class=\"dt\">AccountType</span> <span class=\"fu\">=</span> <span class=\"dt\">Chequing</span> <span class=\"fu\">|</span> <span class=\"dt\">Savings</span></a>\n<a class=\"sourceLine\" id=\"cb17-2\" title=\"2\">  <span class=\"kw\">deriving</span> <span class=\"dt\">Show</span></a>\n<a class=\"sourceLine\" id=\"cb17-3\" title=\"3\"></a>\n<a class=\"sourceLine\" id=\"cb17-4\" title=\"4\"><span class=\"kw\">data</span> <span class=\"dt\">BankAccount</span> <span class=\"fu\">=</span></a>\n<a class=\"sourceLine\" id=\"cb17-5\" title=\"5\">  <span class=\"dt\">BankAccount</span></a>\n<a class=\"sourceLine\" id=\"cb17-6\" title=\"6\">    {<span class=\"ot\"> accountType ::</span> <span class=\"dt\">AccountType</span></a>\n<a class=\"sourceLine\" id=\"cb17-7\" title=\"7\">    ,<span class=\"ot\"> transactions ::</span> [<span class=\"dt\">Transaction</span>]</a>\n<a class=\"sourceLine\" id=\"cb17-8\" title=\"8\">    } <span class=\"kw\">deriving</span> <span class=\"dt\">Show</span></a></code></pre></div>\n<p>For a non-trivial example we'll show how to write a new traversal which uses our existing <code>withdrawals</code> traversal to access the withdrawals nested within a <code>BankAccount</code>!</p>\n<div class=\"sourceCode\" id=\"cb18\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb18-1\" title=\"1\"><span class=\"co\">-- accountWithdrawals :: Traversal&#39; BankAccount Int</span></a>\n<a class=\"sourceLine\" id=\"cb18-2\" title=\"2\"><span class=\"co\">-- a.k.a.</span></a>\n<a class=\"sourceLine\" id=\"cb18-3\" title=\"3\">accountWithdrawals</a>\n<a class=\"sourceLine\" id=\"cb18-4\" title=\"4\"><span class=\"ot\">  ::</span> (<span class=\"dt\">Applicative</span> f) <span class=\"ot\">=&gt;</span> (<span class=\"dt\">Int</span> <span class=\"ot\">-&gt;</span> f <span class=\"dt\">Int</span>) <span class=\"ot\">-&gt;</span> <span class=\"dt\">BankAccount</span> <span class=\"ot\">-&gt;</span> f <span class=\"dt\">BankAccount</span></a>\n<a class=\"sourceLine\" id=\"cb18-5\" title=\"5\">accountWithdrawals f (<span class=\"dt\">BankAccount</span> type&#39; transactions&#39;) <span class=\"fu\">=</span></a>\n<a class=\"sourceLine\" id=\"cb18-6\" title=\"6\">  <span class=\"dt\">BankAccount</span> type&#39; <span class=\"fu\">&lt;$&gt;</span> withdrawals f transactions&#39;</a></code></pre></div>\n<p>Here we simply reconstruct the unaffected parts of <code>BankAccount</code> as normal, when we get to our transactions we need to wrap them in the given applicative and <strong>focus</strong> the appropriate elements using the provided <code>f</code> function. We can rely on the fact that traversals behave just like the regular ol' <code>traverse</code> function! We'll run <code>withdrawals</code> over the list as though it were <code>traverse</code>, passing it <code>f</code> as the function to select values within the structure. Pretty nifty stuff! Now we have a traversal which can access withdrawals from within a bank account!</p>\n<div class=\"sourceCode\" id=\"cb19\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb19-1\" title=\"1\"><span class=\"ot\">account ::</span> <span class=\"dt\">BankAccount</span></a>\n<a class=\"sourceLine\" id=\"cb19-2\" title=\"2\">account <span class=\"fu\">=</span> <span class=\"dt\">BankAccount</span> <span class=\"dt\">Savings</span> [<span class=\"dt\">Deposit</span> <span class=\"dv\">100</span>, <span class=\"dt\">Withdrawal</span> <span class=\"dv\">50</span>]</a>\n<a class=\"sourceLine\" id=\"cb19-3\" title=\"3\"></a>\n<a class=\"sourceLine\" id=\"cb19-4\" title=\"4\">λ<span class=\"fu\">&gt;</span> account <span class=\"fu\">^..</span> accountWithdrawals</a>\n<a class=\"sourceLine\" id=\"cb19-5\" title=\"5\">[<span class=\"dv\">50</span>]</a>\n<a class=\"sourceLine\" id=\"cb19-6\" title=\"6\"></a>\n<a class=\"sourceLine\" id=\"cb19-7\" title=\"7\">λ<span class=\"fu\">&gt;</span> account <span class=\"fu\">&amp;</span> accountWithdrawals <span class=\"fu\">+~</span> <span class=\"dv\">10</span></a>\n<a class=\"sourceLine\" id=\"cb19-8\" title=\"8\"><span class=\"dt\">BankAccount</span> </a>\n<a class=\"sourceLine\" id=\"cb19-9\" title=\"9\">  { accountType <span class=\"fu\">=</span> <span class=\"dt\">Savings</span></a>\n<a class=\"sourceLine\" id=\"cb19-10\" title=\"10\">  , transactions <span class=\"fu\">=</span> [<span class=\"dt\">Deposit</span> {amount <span class=\"fu\">=</span> <span class=\"dv\">100</span>},<span class=\"dt\">Withdrawal</span> {amount <span class=\"fu\">=</span> <span class=\"dv\">60</span>}]}</a></code></pre></div>\n<p>Note that if we have lenses over our <code>BankAccount</code> we can save a bit of work and define the same traversal by <em>composing</em> a lens with our traversal to build the new traversal, assuming <code>transactions :: Lens' BankAccount [Transaction]</code> we get:</p>\n<div class=\"sourceCode\" id=\"cb20\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb20-1\" title=\"1\"><span class=\"ot\">accountWithdrawals ::</span> <span class=\"dt\">Traversal&#39;</span> <span class=\"dt\">BankAccount</span> <span class=\"dt\">Int</span></a>\n<a class=\"sourceLine\" id=\"cb20-2\" title=\"2\">accountWithdrawals <span class=\"fu\">=</span> transactions <span class=\"fu\">.</span> withdrawals</a></code></pre></div>\n<p>That'll do it! Most complex traversals can be built using a combination of these techniques!</p>","title":"Writing Traversals","why":"Traversals can access or alter zero or more elements from throughout a data structure","section":"Traversals"}]